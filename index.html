<!doctype html>
<html lang="cs">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Goon Verse — Meme</title>
<style>
  :root {
    --bg: #080808;
  }
  html,body {
    height:100%;
    margin:0;
    background:var(--bg);
    overflow:hidden;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
  }
  canvas { display:block; width:100vw; height:100vh; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function resize() {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.width  = Math.floor(window.innerWidth  * dpr);
  canvas.height = Math.floor(window.innerHeight * dpr);
  canvas.style.width  = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);
resize();

// helper positions based on current size
function CX(){ return innerWidth/2; }
function baseY(){ return innerHeight * 0.62; }
const titleYratio = 0.25;

// particles accumulate permanently on the canvas (no clearing)
const particles = [];
const MAX_PARTICLES = 9000;

// emission settings
const EMIT_PER_FRAME = 18; // výchozí počet teček / frame
const SPEED = 2.8;
const GRAV = 0.03;

// time
let t = 0;

// draw static-ish lower shapes (we redraw every frame so they stay on top of subtle background)
function drawScene(bounce) {
  // slight dark overlay instead of full clear to keep accumulation visible
  ctx.fillStyle = "rgba(8,8,8,0.06)";
  ctx.fillRect(0,0,innerWidth,innerHeight);

  // Title
  const fontSize = Math.floor(Math.min(innerWidth, innerHeight) * 0.10);
  ctx.font = `800 ${fontSize}px system-ui, -apple-system, "Segoe UI", Roboto`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  // subtle gradient for title
  const g = ctx.createLinearGradient(CX() - 200, innerHeight*titleYratio, CX() + 200, innerHeight*titleYratio);
  g.addColorStop(0, '#ffffff'); g.addColorStop(1, '#cfcfcf');
  ctx.fillStyle = g;
  ctx.fillText("GOON VERSE", CX(), innerHeight * titleYratio);

  // coordinates for shapes
  const cx = CX();
  const by = baseY();

  // ground shadow
  ctx.beginPath();
  ctx.ellipse(cx, by + 96, 140, 30, 0, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fill();

  // dvě velké koule (jasně viditelné pod oválem)
  ctx.fillStyle = '#111';
  // left circle
  ctx.beginPath();
  ctx.arc(cx - 66, by + 10, 52, 0, Math.PI*2);
  ctx.fill();
  // right circle
  ctx.beginPath();
  ctx.arc(cx + 66, by + 10, 52, 0, Math.PI*2);
  ctx.fill();

  // outline for emphasis (cartoon look)
  ctx.lineWidth = 3;
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.beginPath();
  ctx.arc(cx - 66, by + 10, 52, 0, Math.PI*2);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(cx + 66, by + 10, 52, 0, Math.PI*2);
  ctx.stroke();

  // hlavní střední tělo (ovál) — trochu nad koulemi
  const ovalRx = 46;
  const ovalRy = 92;
  const ovalX = cx;
  const ovalY = by - 46 - bounce; // bounce posun
  ctx.beginPath();
  ctx.ellipse(ovalX, ovalY, ovalRx, ovalRy, 0, 0, Math.PI*2);
  ctx.fillStyle = '#111';
  ctx.fill();

  // glossy highlights
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.beginPath();
  ctx.ellipse(ovalX - 18, ovalY - 24, 14, 34, -0.5, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(ovalX + 30, ovalY + 6, 10, 20, 0.4, 0, Math.PI*2);
  ctx.fill();

  // return coordinates for emitter (top of oval)
  return { x: ovalX, y: ovalY - ovalRy + 6 };
}

// simple particle emitter: we simulate a few steps, then draw final dot permanently
function emitFrom(x, y, n) {
  for (let i=0;i<n;i++){
    if (particles.length >= MAX_PARTICLES) break;
    // initial random velocity upward-ish
    const angle = -Math.PI/2 + (Math.random()-0.5) * 1.2;
    const spd = SPEED * (0.6 + Math.random()*1.1);
    let vx = Math.cos(angle) * spd + (Math.random()-0.5)*0.6;
    let vy = Math.sin(angle) * spd + (Math.random()-0.5)*0.6;
    let px = x + (Math.random()-0.5) * 12;
    let py = y + (Math.random()-0.5) * 6;

    // simulate short trajectory
    const steps = 10 + Math.floor(Math.random()*20);
    for (let s=0;s<steps;s++){
      vy += GRAV;
      px += vx;
      py += vy;
    }

    // draw permanent dot
    const r = 0.9 + Math.random()*3.6;
    const a = 0.85 - Math.random()*0.35;
    ctx.beginPath();
    ctx.fillStyle = `rgba(255,255,255,${a})`;
    ctx.arc(px, py, r, 0, Math.PI*2);
    ctx.fill();

    particles.push({}); // just track count
  }
}

// main loop
function loop(){
  t += 0.05;
  // bounce value (smooth)
  const bounceAmp = Math.min(38, innerHeight / 40);
  const bounce = Math.abs(Math.sin(t * 1.8)) * bounceAmp;

  // draw scene and get emitter point
  const emitter = drawScene(bounce);

  // emit a bunch per frame from top of oval
  emitFrom(emitter.x, emitter.y, EMIT_PER_FRAME);

  // small occasional heavier bursts so fill looks organic
  if (Math.random() < 0.07) {
    emitFrom(emitter.x + (Math.random()-0.5)*40, emitter.y + (Math.random()-0.5)*10, 6 + Math.floor(Math.random()*12));
  }

  // loop
  requestAnimationFrame(loop);
}

// start
// small initial dark clear so shapes show cleanly at load
ctx.fillStyle = '#080808';
ctx.fillRect(0,0,innerWidth,innerHeight);
requestAnimationFrame(loop);
</script>
</body>
</html>
