<!doctype html>
<html lang="cs">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Goon Verse</title>
<style>
  :root {
    --bg: #080808;
    --accent: #ffffff;
  }
  html,body {
    height: 100%;
    margin: 0;
    background: var(--bg);
    overflow: hidden;
  }
  canvas {
    display:block;
    width:100vw;
    height:100vh;
    background: var(--bg);
    cursor: pointer;
    user-select: none;
  }
  #hint {
    position: fixed;
    right: 12px;
    bottom: 12px;
    color: rgba(255,255,255,0.45);
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    font-size: 12px;
    user-select:none;
    pointer-events: none;
  }
  /* small responsive text hint for mobile */
  @media (max-width:420px) {
    #hint { font-size: 11px; right:8px; bottom:8px; }
  }
</style>
</head>
<body>
<canvas id="c" aria-label="Goon Verse meme canvas"></canvas>
<div id="hint">klik = intensify / Space nebo R = reset</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  // Hi-DPI setup
  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    drawBase(); // draw static elements once after resize
  }
  addEventListener('resize', resize);
  resize();

  // PARAMETERS (lehce měnitelné)
  let emitPerFrame = 90;     // základní počet emitů za frame
  const BASE_EMIT = emitPerFrame;
  const particleLife = 80;   // frames
  const speed = 2.8;
  const gravity = 0.02;
  const maxParticles = 3000; // bezpečnostní limit
  let intensifyTimeout = null;

  // totem position (nastaví drawBase)
  let holeX = innerWidth / 2;
  let holeY = innerHeight * 0.5;

  // particles array
  let particles = [];

  // draw base: background, title, cartoon totem
  let baseDrawn = false;
  function drawBase() {
    // fill background (this WILL clear canvas when called)
    ctx.fillStyle = '#080808';
    ctx.fillRect(0,0,innerWidth,innerHeight);

    // Title
    const title = "GOON VERSE";
    const fontSize = Math.floor(Math.min(innerWidth, innerHeight) * 0.12);
    ctx.font = `800 ${fontSize}px system-ui, -apple-system, "Segoe UI", Roboto, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // subtle gradient-ish text
    const grad = ctx.createLinearGradient(innerWidth/2 - 220, innerHeight*0.28, innerWidth/2 + 220, innerHeight*0.28);
    grad.addColorStop(0, '#f7f7f7');
    grad.addColorStop(1, '#cfcfcf');
    ctx.fillStyle = grad;
    ctx.fillText(title, innerWidth / 2, innerHeight * 0.28);

    // cartoon totem coordinates
    const cx = innerWidth / 2;
    const baseY = innerHeight * 0.58;

    // store emitter point (vršek oválu)
    holeX = cx;
    holeY = baseY - 100;

    // draw a soft shadow/ground hint
    ctx.beginPath();
    ctx.ellipse(cx, baseY + 88, 120, 26, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fill();

    // TOTEM shapes (filled dark shapes)
    // We'll draw them with a slight glossy stroke to look "cartoony"

    // left sphere
    ctx.beginPath();
    ctx.arc(cx - 54, baseY + 10, 44, 0, Math.PI * 2);
    ctx.fillStyle = '#111';
    ctx.fill();

    // right sphere
    ctx.beginPath();
    ctx.arc(cx + 54, baseY + 10, 44, 0, Math.PI * 2);
    ctx.fill();

    // main oval body
    ctx.beginPath();
    ctx.ellipse(cx, baseY - 40, 46, 88, 0, 0, Math.PI * 2);
    ctx.fill();

    // small glossy highlights (cartoon style)
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.beginPath();
    ctx.ellipse(cx - 20, baseY - 60, 14, 36, -0.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(cx + 36, baseY - 10, 10, 22, 0.4, 0, Math.PI * 2);
    ctx.fill();

    // small ring/neck to imply "top"
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.ellipse(cx, baseY - 108, 28, 8, 0, 0, Math.PI * 2);
    ctx.stroke();

    baseDrawn = true;
  }

  // emit a single particle from the hole (with a bit of spread)
  function emitOne() {
    if (particles.length > maxParticles) return;
    // angle mainly upwards with spread
    const angle = -Math.PI/2 + (Math.random() - 0.5) * 1.2; // up +/- ~34deg
    const spd = speed * (0.5 + Math.random() * 1.2);
    const vx = Math.cos(angle) * spd + (Math.random() - 0.5) * 0.6;
    const vy = Math.sin(angle) * spd + (Math.random() - 0.5) * 0.6;
    const size = Math.max(0.8, Math.random() * 4.0);
    particles.push({
      x: holeX + (Math.random()-0.5) * 18,
      y: holeY + (Math.random()-0.5) * 8,
      vx, vy, life: particleLife + Math.round(Math.random()*20), size
    });
  }

  function emitMany(n) {
    for (let i=0;i<n;i++) emitOne();
  }

  // animation loop (we DON'T clear the canvas each frame, so particles accumulate)
  let raf;
  function frame(time) {
    // update and draw particles (without clearing)
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.vy += gravity;
      p.x += p.vx;
      p.y += p.vy;
      p.life--;

      // draw particle
      ctx.beginPath();
      // small alpha variation for texture
      const alpha = 0.9 - Math.random()*0.25;
      ctx.fillStyle = 'rgba(255,255,255,' + alpha + ')';
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fill();

      if (p.life <= 0 || p.x < -50 || p.x > innerWidth + 50 || p.y > innerHeight + 50) {
        particles.splice(i,1);
      }
    }

    // emit new
    emitMany(emitPerFrame);

    raf = requestAnimationFrame(frame);
  }

  // start
  drawBase();
  // short delay then start emitting so base is visible first
  setTimeout(() => { frame(); }, 120);

  // CLICK = intensify (temporary increase of emitPerFrame + slight screen shake)
  canvas.addEventListener('click', () => {
    // intensify
    emitPerFrame = Math.min(700, emitPerFrame * 4 + 50);
    if (intensifyTimeout) clearTimeout(intensifyTimeout);

    // tiny screen shake effect: translate canvas context for few frames by overriding drawBase temporarily
    const shakeFrames = 10;
    let shakeCount = 0;
    const originalDrawBase = drawBase;
    // we'll perform a quick layered shake (draw base + little jitter) then resume
    function shakeOnce() {
      if (!baseDrawn) return;
      const jitter = (Math.random() - 0.5) * 8;
      ctx.save();
      ctx.translate(jitter, (Math.random()-0.5)*6);
      originalDrawBase();
      ctx.restore();
      shakeCount++;
      if (shakeCount < shakeFrames) {
        requestAnimationFrame(shakeOnce);
      }
    }
    shakeOnce();

    intensifyTimeout = setTimeout(() => {
      emitPerFrame = BASE_EMIT;
      intensifyTimeout = null;
    }, 600);
  });

  // reset function: clears all particles and redraws base
  function resetAll() {
    particles.length = 0;
    cancelAnimationFrame(raf);
    // fully clear canvas
    ctx.fillStyle = '#080808';
    ctx.fillRect(0,0,innerWidth,innerHeight);
    drawBase();
    // small delay then resume
    setTimeout(() => frame(), 80);
  }

  // keyboard controls: Space or 'r' resets
  addEventListener('keydown', (e) => {
    if (e.code === 'Space' || (e.key && e.key.toLowerCase() === 'r')) {
      e.preventDefault();
      resetAll();
    }
  });

  // safety: if tab hidden, pause emitting to save perf
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) cancelAnimationFrame(raf);
    else frame();
  });

  // mobile touch: same as click
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    canvas.click();
  }, { passive: false });

})();
</script>
</body>
</html>
