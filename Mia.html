<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mia AI</title>
    <script src="https://www.youtube.com/iframe_api"></script>
    <style>
        body { 
            background-color: #050505; 
            color: #fff; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, sans-serif; 
            margin: 0; 
            display: flex; 
            flex-direction: column; 
            height: 100dvh; 
            overflow: hidden; 
        }
        #viz-container { 
            flex: 0 0 150px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            position: relative; 
            background: radial-gradient(circle at center, #1a1a1a 0%, #050505 70%);
        }
        canvas { width: 100%; height: 100%; }
        #chat-container { 
            flex: 1; 
            overflow-y: auto; 
            padding: 20px; 
            display: flex; 
            flex-direction: column; 
            gap: 15px; 
            scroll-behavior: smooth; 
        }
        .msg { 
            max-width: 85%; 
            padding: 12px 16px; 
            border-radius: 18px; 
            font-size: 0.95rem; 
            line-height: 1.5; 
            animation: fadeIn 0.3s ease; 
        }
        .user { align-self: flex-end; background: #333; color: #fff; border-bottom-right-radius: 4px; }
        .bot { align-self: flex-start; background: #111; color: #ddd; border-bottom-left-radius: 4px; border: 1px solid #222; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        #input-container { 
            padding: 20px; 
            display: flex; 
            gap: 10px; 
            background: #050505; 
            border-top: 1px solid #222; 
        }
        input { 
            flex: 1; 
            background: #111; 
            border: 1px solid #333; 
            border-radius: 25px; 
            color: #fff; 
            padding: 12px 20px; 
            outline: none; 
            font-size: 16px; 
        }
        button { 
            background: #fff; 
            color: #000; 
            border: none; 
            border-radius: 50%; 
            width: 45px; 
            height: 45px; 
            cursor: pointer; 
            font-weight: bold; 
            transition: transform 0.1s; 
        }
        button:active { transform: scale(0.95); }
        button:disabled { opacity: 0.5; }
        #youtube-player { position: absolute; top: -9999px; left: -9999px; visibility: hidden; }
        .status-indicator {
            position: absolute; bottom: 10px; right: 10px;
            font-size: 10px; color: #555; text-transform: uppercase; letter-spacing: 1px;
        }
    </style>
</head>
<body>

<div id="viz-container">
    <canvas id="canvas"></canvas>
    <div class="status-indicator" id="statusText">IDLE</div>
</div>

<div id="chat-container"></div>

<div id="input-container">
    <input type="text" id="userInput" placeholder="Message Mia..." autocomplete="off">
    <button id="sendBtn">➤</button>
</div>

<div id="youtube-player"></div>

<script>
    let audioCtx, analyser, source, dataArray, canvasCtx, animationId;
    let ytPlayer;
    let isVoicePlaying = false;
    let isMusicPlaying = false;
    let conversationHistory = [];

    const canvas = document.getElementById('canvas');
    canvas.width = window.innerWidth;
    canvas.height = 150;
    canvasCtx = canvas.getContext('2d');
    const statusText = document.getElementById('statusText');
    const chatContainer = document.getElementById('chat-container');
    const userInput = document.getElementById('userInput');
    const sendBtn = document.getElementById('sendBtn');

    function onYouTubeIframeAPIReady() {
        ytPlayer = new YT.Player('youtube-player', {
            height: '0', width: '0',
            playerVars: { 'autoplay': 0, 'controls': 0 },
            events: { 'onStateChange': onPlayerStateChange }
        });
    }

    function onPlayerStateChange(event) {
        if (event.data === YT.PlayerState.PLAYING) {
            isMusicPlaying = true;
            statusText.innerText = `PLAYING`;
            if (!isVoicePlaying) startVisualizer('music');
            // try to get title
            try { const info = ytPlayer.getVideoData(); if (info && info.title) statusText.innerText = `NOW PLAYING: ${info.title}`; } catch(e){}
        } else if (event.data === YT.PlayerState.ENDED || event.data === YT.PlayerState.PAUSED) {
            isMusicPlaying = false;
            if (!isVoicePlaying) {
                stopVisualizer();
                statusText.innerText = "IDLE";
            }
        }
    }

    function extractYouTubeId(url) {
        if (!url) return null;
        const regex = /(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/(.[A-Za-z0-9_-]{11}))/;
        const m = url.match(regex);
        return m ? m[1] : null;
    }

    function isPlayCommand(text) {
        if (!text) return null;
        // detect direct link
        const yt = extractYouTubeId(text);
        if (yt) return { type: 'youtube', id: yt, display: text };
        // detect natural language commands like "pust Kendricka Lamara - Swimming Pools" or "play ..."
        const playMatch = text.match(/(?:pust|prehrat|přehrát|přehraj|play)\s+(.+)/i);
        if (playMatch) return { type: 'search', query: playMatch[1].trim(), display: playMatch[1].trim() };
        // also support "Artist - Song" without keyword
        const dashMatch = text.match(/^(.*{2,100})\s-\s(.{1,100})$/);
        if (dashMatch) return { type: 'search', query: text.trim(), display: text.trim() };
        return null;
    }

    function playMusicCommand(cmd) {
        if (!cmd) return;
        if (cmd.type === 'youtube') {
            if (ytPlayer && ytPlayer.loadVideoById) {
                ytPlayer.loadVideoById(cmd.id);
            }
        } else if (cmd.type === 'search') {
            if (ytPlayer && ytPlayer.loadPlaylist) {
                ytPlayer.loadPlaylist({ listType: 'search', list: cmd.query, index: 0, startSeconds: 0 });
            }
        }
    }

    async function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 256;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
        }
        if (audioCtx.state === 'suspended') await audioCtx.resume();
    }

    async function playVoice(base64Audio) {
        await initAudio();
        
        if (isMusicPlaying && ytPlayer) ytPlayer.setVolume && ytPlayer.setVolume(20);
        
        try {
            const binaryString = window.atob(base64Audio);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);

            const buffer = await audioCtx.decodeAudioData(bytes.buffer);
            if (source) source.stop();

            source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(analyser);
            analyser.connect(audioCtx.destination);

            source.onended = () => {
                isVoicePlaying = false;
                if (isMusicPlaying) {
                    if(ytPlayer && ytPlayer.setVolume) ytPlayer.setVolume(100);
                    startVisualizer('music');
                } else {
                    stopVisualizer();
                    statusText.innerText = "IDLE";
                }
            };

            isVoicePlaying = true;
            statusText.innerText = "SPEAKING";
            startVisualizer('voice');
            source.start(0);
        } catch (e) {
            console.error('Voice playback failed', e);
            // fallback to Web Speech API
            return false;
        }
        return true;
    }

    function speakFallback(text) {
        if (!('speechSynthesis' in window)) return;
        try {
            const u = new SpeechSynthesisUtterance(text);
            speechSynthesis.cancel();
            speechSynthesis.speak(u);
        } catch (e) { console.error(e); }
    }

    function startVisualizer(mode) {
        if (animationId) cancelAnimationFrame(animationId);
        let pulse = 0;

        function draw() {
            animationId = requestAnimationFrame(draw);
            canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

            const bars = 50;
            const barWidth = canvas.width / bars;
            const centerX = canvas.height / 2;
            pulse += 0.05;

            if (mode === 'voice') {
                analyser.getByteFrequencyData(dataArray);
                canvasCtx.fillStyle = '#fff';
                for (let i = 0; i < bars; i++) {
                    const h = (dataArray[i * 2] / 255) * 100;
                    const x = i * barWidth;
                    canvasCtx.fillRect(x, centerX - h/2, barWidth - 2, h);
                }
            } else if (mode === 'music') {
                const time = Date.now() / 200;
                const glow = (Math.sin(pulse) + 1) / 2 * 0.6 + 0.4; // 0.4..1.0
                for (let i = 0; i < bars; i++) {
                    const h = Math.sin(i * 0.2 + time) * 30 + Math.random() * 20 + 10;
                    const hue = (i * 5 + time * 50) % 360;
                    canvasCtx.fillStyle = `hsla(${hue}, 70%, ${50 * glow}%, ${0.9})`;
                    const x = i * barWidth;
                    canvasCtx.fillRect(x, centerX - h/2, barWidth - 2, h);
                }
            }
        }
        draw();
    }

    function stopVisualizer() {
        if (animationId) cancelAnimationFrame(animationId);
        canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function appendMessage(role, text) {
        const div = document.createElement('div');
        div.className = `msg ${role}`;
        div.innerText = text;
        chatContainer.appendChild(div);
        chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    async function sendMessage() {
        const text = userInput.value.trim();
        if (!text) return;

        await initAudio(); 

        appendMessage('user', text);
        userInput.value = '';
        sendBtn.disabled = true;
        
        conversationHistory.push({ role: "user", content: text });

        // detect play command locally and react immediately
        const playCmd = isPlayCommand(text);
        if (playCmd) {
            // show immediate assistant reply
            appendMessage('bot', `Now playing ${playCmd.display}`);
            // start playing (will update status when YT player starts)
            playMusicCommand(playCmd);
        }

        try {
            const res = await fetch('/api/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ messages: conversationHistory })
            });
            const data = await res.json();

            // Handle Music Command from assistant (if present)
            let displayText = data.text || '';  
            const musicMatch = displayText.match(/\[PLAY:(.*?)\]/);
            if (musicMatch) {
                const song = musicMatch[1].trim();
                playMusicCommand({ type: 'search', query: song, display: song });
                displayText = displayText.replace(musicMatch[0], '').trim();
                // show assistant's now playing message
                appendMessage('bot', `Now playing ${song}`);
            } else if (!playCmd && displayText) {
                appendMessage('bot', displayText);
            }

            conversationHistory.push({ role: "assistant", content: data.text });
            
            // Play TTS if available, otherwise use speechSynthesis fallback
            if (data.audio) {
                const ok = await playVoice(data.audio);
                if (!ok) speakFallback(displayText || data.text || '');
            } else {
                // fallback
                speakFallback(displayText || data.text || '');
            }

        } catch (e) {
            console.error(e);
            appendMessage('bot', "Error connecting to Mia.");
        } finally {
            sendBtn.disabled = false;
        }
    }

    sendBtn.onclick = sendMessage;
    userInput.onkeypress = (e) => e.key === 'Enter' ? sendMessage() : null;
    window.onresize = () => { canvas.width = window.innerWidth; };
</script>
</body>
</html>
